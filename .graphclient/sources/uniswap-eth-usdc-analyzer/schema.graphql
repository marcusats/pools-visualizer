schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type DailyStat {
  id: ID!
  totalVolume: BigDecimal!
  totalTransactions: BigInt!
  timestamp: BigInt!
}

input DailyStat_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalVolume: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_lt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_not_in: [BigDecimal!]
  totalTransactions: BigInt
  totalTransactions_not: BigInt
  totalTransactions_gt: BigInt
  totalTransactions_lt: BigInt
  totalTransactions_gte: BigInt
  totalTransactions_lte: BigInt
  totalTransactions_in: [BigInt!]
  totalTransactions_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DailyStat_filter]
  or: [DailyStat_filter]
}

enum DailyStat_orderBy {
  id
  totalVolume
  totalTransactions
  timestamp
}

type FeeCollection {
  id: ID!
  owner: Bytes!
  recipient: Bytes!
  amount0: BigInt!
  amount1: BigInt!
  eventType: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input FeeCollection_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  recipient: Bytes
  recipient_not: Bytes
  recipient_gt: Bytes
  recipient_lt: Bytes
  recipient_gte: Bytes
  recipient_lte: Bytes
  recipient_in: [Bytes!]
  recipient_not_in: [Bytes!]
  recipient_contains: Bytes
  recipient_not_contains: Bytes
  amount0: BigInt
  amount0_not: BigInt
  amount0_gt: BigInt
  amount0_lt: BigInt
  amount0_gte: BigInt
  amount0_lte: BigInt
  amount0_in: [BigInt!]
  amount0_not_in: [BigInt!]
  amount1: BigInt
  amount1_not: BigInt
  amount1_gt: BigInt
  amount1_lt: BigInt
  amount1_gte: BigInt
  amount1_lte: BigInt
  amount1_in: [BigInt!]
  amount1_not_in: [BigInt!]
  eventType: String
  eventType_not: String
  eventType_gt: String
  eventType_lt: String
  eventType_gte: String
  eventType_lte: String
  eventType_in: [String!]
  eventType_not_in: [String!]
  eventType_contains: String
  eventType_contains_nocase: String
  eventType_not_contains: String
  eventType_not_contains_nocase: String
  eventType_starts_with: String
  eventType_starts_with_nocase: String
  eventType_not_starts_with: String
  eventType_not_starts_with_nocase: String
  eventType_ends_with: String
  eventType_ends_with_nocase: String
  eventType_not_ends_with: String
  eventType_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FeeCollection_filter]
  or: [FeeCollection_filter]
}

enum FeeCollection_orderBy {
  id
  owner
  recipient
  amount0
  amount1
  eventType
  blockNumber
  timestamp
}

type FlashLoan {
  id: ID!
  sender: Bytes!
  recipient: Bytes!
  amount0: BigInt!
  amount1: BigInt!
  paid0: BigInt!
  paid1: BigInt!
  totalFlashLoanSize: BigInt!
  numberOfLoans: BigInt!
  blockNumber: BigInt!
  timestamp: BigInt!
}

type FlashLoanAmount {
  id: ID!
  flashLoan: FlashLoan!
  amountSize: BigInt!
}

input FlashLoanAmount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  flashLoan: String
  flashLoan_not: String
  flashLoan_gt: String
  flashLoan_lt: String
  flashLoan_gte: String
  flashLoan_lte: String
  flashLoan_in: [String!]
  flashLoan_not_in: [String!]
  flashLoan_contains: String
  flashLoan_contains_nocase: String
  flashLoan_not_contains: String
  flashLoan_not_contains_nocase: String
  flashLoan_starts_with: String
  flashLoan_starts_with_nocase: String
  flashLoan_not_starts_with: String
  flashLoan_not_starts_with_nocase: String
  flashLoan_ends_with: String
  flashLoan_ends_with_nocase: String
  flashLoan_not_ends_with: String
  flashLoan_not_ends_with_nocase: String
  flashLoan_: FlashLoan_filter
  amountSize: BigInt
  amountSize_not: BigInt
  amountSize_gt: BigInt
  amountSize_lt: BigInt
  amountSize_gte: BigInt
  amountSize_lte: BigInt
  amountSize_in: [BigInt!]
  amountSize_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FlashLoanAmount_filter]
  or: [FlashLoanAmount_filter]
}

enum FlashLoanAmount_orderBy {
  id
  flashLoan
  flashLoan__id
  flashLoan__sender
  flashLoan__recipient
  flashLoan__amount0
  flashLoan__amount1
  flashLoan__paid0
  flashLoan__paid1
  flashLoan__totalFlashLoanSize
  flashLoan__numberOfLoans
  flashLoan__blockNumber
  flashLoan__timestamp
  amountSize
}

input FlashLoan_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  recipient: Bytes
  recipient_not: Bytes
  recipient_gt: Bytes
  recipient_lt: Bytes
  recipient_gte: Bytes
  recipient_lte: Bytes
  recipient_in: [Bytes!]
  recipient_not_in: [Bytes!]
  recipient_contains: Bytes
  recipient_not_contains: Bytes
  amount0: BigInt
  amount0_not: BigInt
  amount0_gt: BigInt
  amount0_lt: BigInt
  amount0_gte: BigInt
  amount0_lte: BigInt
  amount0_in: [BigInt!]
  amount0_not_in: [BigInt!]
  amount1: BigInt
  amount1_not: BigInt
  amount1_gt: BigInt
  amount1_lt: BigInt
  amount1_gte: BigInt
  amount1_lte: BigInt
  amount1_in: [BigInt!]
  amount1_not_in: [BigInt!]
  paid0: BigInt
  paid0_not: BigInt
  paid0_gt: BigInt
  paid0_lt: BigInt
  paid0_gte: BigInt
  paid0_lte: BigInt
  paid0_in: [BigInt!]
  paid0_not_in: [BigInt!]
  paid1: BigInt
  paid1_not: BigInt
  paid1_gt: BigInt
  paid1_lt: BigInt
  paid1_gte: BigInt
  paid1_lte: BigInt
  paid1_in: [BigInt!]
  paid1_not_in: [BigInt!]
  totalFlashLoanSize: BigInt
  totalFlashLoanSize_not: BigInt
  totalFlashLoanSize_gt: BigInt
  totalFlashLoanSize_lt: BigInt
  totalFlashLoanSize_gte: BigInt
  totalFlashLoanSize_lte: BigInt
  totalFlashLoanSize_in: [BigInt!]
  totalFlashLoanSize_not_in: [BigInt!]
  numberOfLoans: BigInt
  numberOfLoans_not: BigInt
  numberOfLoans_gt: BigInt
  numberOfLoans_lt: BigInt
  numberOfLoans_gte: BigInt
  numberOfLoans_lte: BigInt
  numberOfLoans_in: [BigInt!]
  numberOfLoans_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FlashLoan_filter]
  or: [FlashLoan_filter]
}

enum FlashLoan_orderBy {
  id
  sender
  recipient
  amount0
  amount1
  paid0
  paid1
  totalFlashLoanSize
  numberOfLoans
  blockNumber
  timestamp
}

"""
8 bytes signed integer

"""
scalar Int8

type LastSwapPerBlock {
  id: ID!
  lastSwapId: String!
}

input LastSwapPerBlock_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastSwapId: String
  lastSwapId_not: String
  lastSwapId_gt: String
  lastSwapId_lt: String
  lastSwapId_gte: String
  lastSwapId_lte: String
  lastSwapId_in: [String!]
  lastSwapId_not_in: [String!]
  lastSwapId_contains: String
  lastSwapId_contains_nocase: String
  lastSwapId_not_contains: String
  lastSwapId_not_contains_nocase: String
  lastSwapId_starts_with: String
  lastSwapId_starts_with_nocase: String
  lastSwapId_not_starts_with: String
  lastSwapId_not_starts_with_nocase: String
  lastSwapId_ends_with: String
  lastSwapId_ends_with_nocase: String
  lastSwapId_not_ends_with: String
  lastSwapId_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LastSwapPerBlock_filter]
  or: [LastSwapPerBlock_filter]
}

enum LastSwapPerBlock_orderBy {
  id
  lastSwapId
}

type MarketVolatility {
  id: ID!
  totalVolatility: BigDecimal!
  lastUpdated: BigInt!
}

input MarketVolatility_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalVolatility: BigDecimal
  totalVolatility_not: BigDecimal
  totalVolatility_gt: BigDecimal
  totalVolatility_lt: BigDecimal
  totalVolatility_gte: BigDecimal
  totalVolatility_lte: BigDecimal
  totalVolatility_in: [BigDecimal!]
  totalVolatility_not_in: [BigDecimal!]
  lastUpdated: BigInt
  lastUpdated_not: BigInt
  lastUpdated_gt: BigInt
  lastUpdated_lt: BigInt
  lastUpdated_gte: BigInt
  lastUpdated_lte: BigInt
  lastUpdated_in: [BigInt!]
  lastUpdated_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MarketVolatility_filter]
  or: [MarketVolatility_filter]
}

enum MarketVolatility_orderBy {
  id
  totalVolatility
  lastUpdated
}

type ObservationCardinality {
  id: ID!
  oldCardinality: Int!
  newCardinality: Int!
  timestamp: BigInt!
}

input ObservationCardinality_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  oldCardinality: Int
  oldCardinality_not: Int
  oldCardinality_gt: Int
  oldCardinality_lt: Int
  oldCardinality_gte: Int
  oldCardinality_lte: Int
  oldCardinality_in: [Int!]
  oldCardinality_not_in: [Int!]
  newCardinality: Int
  newCardinality_not: Int
  newCardinality_gt: Int
  newCardinality_lt: Int
  newCardinality_gte: Int
  newCardinality_lte: Int
  newCardinality_in: [Int!]
  newCardinality_not_in: [Int!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ObservationCardinality_filter]
  or: [ObservationCardinality_filter]
}

enum ObservationCardinality_orderBy {
  id
  oldCardinality
  newCardinality
  timestamp
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PriceImpact {
  id: ID!
  swapEvent: Swap!
  priceBefore: BigDecimal!
  priceAfter: BigDecimal!
  impact: BigDecimal!
}

input PriceImpact_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  swapEvent: String
  swapEvent_not: String
  swapEvent_gt: String
  swapEvent_lt: String
  swapEvent_gte: String
  swapEvent_lte: String
  swapEvent_in: [String!]
  swapEvent_not_in: [String!]
  swapEvent_contains: String
  swapEvent_contains_nocase: String
  swapEvent_not_contains: String
  swapEvent_not_contains_nocase: String
  swapEvent_starts_with: String
  swapEvent_starts_with_nocase: String
  swapEvent_not_starts_with: String
  swapEvent_not_starts_with_nocase: String
  swapEvent_ends_with: String
  swapEvent_ends_with_nocase: String
  swapEvent_not_ends_with: String
  swapEvent_not_ends_with_nocase: String
  swapEvent_: Swap_filter
  priceBefore: BigDecimal
  priceBefore_not: BigDecimal
  priceBefore_gt: BigDecimal
  priceBefore_lt: BigDecimal
  priceBefore_gte: BigDecimal
  priceBefore_lte: BigDecimal
  priceBefore_in: [BigDecimal!]
  priceBefore_not_in: [BigDecimal!]
  priceAfter: BigDecimal
  priceAfter_not: BigDecimal
  priceAfter_gt: BigDecimal
  priceAfter_lt: BigDecimal
  priceAfter_gte: BigDecimal
  priceAfter_lte: BigDecimal
  priceAfter_in: [BigDecimal!]
  priceAfter_not_in: [BigDecimal!]
  impact: BigDecimal
  impact_not: BigDecimal
  impact_gt: BigDecimal
  impact_lt: BigDecimal
  impact_gte: BigDecimal
  impact_lte: BigDecimal
  impact_in: [BigDecimal!]
  impact_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PriceImpact_filter]
  or: [PriceImpact_filter]
}

enum PriceImpact_orderBy {
  id
  swapEvent
  swapEvent__id
  swapEvent__sender
  swapEvent__recipient
  swapEvent__amount0
  swapEvent__amount1
  swapEvent__sqrtPriceX96
  swapEvent__liquidity
  swapEvent__tick
  swapEvent__blockNumber
  swapEvent__blockTimestamp
  swapEvent__transactionHash
  priceBefore
  priceAfter
  impact
}

type Query {
  feeCollection(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeCollection
  feeCollections(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeCollection_orderBy
    orderDirection: OrderDirection
    where: FeeCollection_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeCollection!]!
  lastSwapPerBlock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LastSwapPerBlock
  lastSwapPerBlocks(
    skip: Int = 0
    first: Int = 100
    orderBy: LastSwapPerBlock_orderBy
    orderDirection: OrderDirection
    where: LastSwapPerBlock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LastSwapPerBlock!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  priceImpact(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceImpact
  priceImpacts(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceImpact_orderBy
    orderDirection: OrderDirection
    where: PriceImpact_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceImpact!]!
  tradeSize(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeSize
  tradeSizes(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeSize_orderBy
    orderDirection: OrderDirection
    where: TradeSize_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeSize!]!
  flashLoan(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlashLoan
  flashLoans(
    skip: Int = 0
    first: Int = 100
    orderBy: FlashLoan_orderBy
    orderDirection: OrderDirection
    where: FlashLoan_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlashLoan!]!
  marketVolatility(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketVolatility
  marketVolatilities(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketVolatility_orderBy
    orderDirection: OrderDirection
    where: MarketVolatility_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketVolatility!]!
  swapAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapAmount
  swapAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapAmount_orderBy
    orderDirection: OrderDirection
    where: SwapAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapAmount!]!
  flashLoanAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlashLoanAmount
  flashLoanAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: FlashLoanAmount_orderBy
    orderDirection: OrderDirection
    where: FlashLoanAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlashLoanAmount!]!
  observationCardinality(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObservationCardinality
  observationCardinalities(
    skip: Int = 0
    first: Int = 100
    orderBy: ObservationCardinality_orderBy
    orderDirection: OrderDirection
    where: ObservationCardinality_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ObservationCardinality!]!
  dailyStat(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyStat
  dailyStats(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyStat_orderBy
    orderDirection: OrderDirection
    where: DailyStat_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyStat!]!
  userActivity(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserActivity
  userActivities(
    skip: Int = 0
    first: Int = 100
    orderBy: UserActivity_orderBy
    orderDirection: OrderDirection
    where: UserActivity_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserActivity!]!
  relayActivity(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RelayActivity
  relayActivities(
    skip: Int = 0
    first: Int = 100
    orderBy: RelayActivity_orderBy
    orderDirection: OrderDirection
    where: RelayActivity_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RelayActivity!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RelayActivity {
  id: ID!
  numberOfSwaps: BigInt!
  totalVolume: BigDecimal!
}

input RelayActivity_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numberOfSwaps: BigInt
  numberOfSwaps_not: BigInt
  numberOfSwaps_gt: BigInt
  numberOfSwaps_lt: BigInt
  numberOfSwaps_gte: BigInt
  numberOfSwaps_lte: BigInt
  numberOfSwaps_in: [BigInt!]
  numberOfSwaps_not_in: [BigInt!]
  totalVolume: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_lt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RelayActivity_filter]
  or: [RelayActivity_filter]
}

enum RelayActivity_orderBy {
  id
  numberOfSwaps
  totalVolume
}

type Subscription {
  feeCollection(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeCollection
  feeCollections(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeCollection_orderBy
    orderDirection: OrderDirection
    where: FeeCollection_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeCollection!]!
  lastSwapPerBlock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LastSwapPerBlock
  lastSwapPerBlocks(
    skip: Int = 0
    first: Int = 100
    orderBy: LastSwapPerBlock_orderBy
    orderDirection: OrderDirection
    where: LastSwapPerBlock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LastSwapPerBlock!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  priceImpact(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceImpact
  priceImpacts(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceImpact_orderBy
    orderDirection: OrderDirection
    where: PriceImpact_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceImpact!]!
  tradeSize(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeSize
  tradeSizes(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeSize_orderBy
    orderDirection: OrderDirection
    where: TradeSize_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeSize!]!
  flashLoan(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlashLoan
  flashLoans(
    skip: Int = 0
    first: Int = 100
    orderBy: FlashLoan_orderBy
    orderDirection: OrderDirection
    where: FlashLoan_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlashLoan!]!
  marketVolatility(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketVolatility
  marketVolatilities(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketVolatility_orderBy
    orderDirection: OrderDirection
    where: MarketVolatility_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketVolatility!]!
  swapAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapAmount
  swapAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapAmount_orderBy
    orderDirection: OrderDirection
    where: SwapAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapAmount!]!
  flashLoanAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlashLoanAmount
  flashLoanAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: FlashLoanAmount_orderBy
    orderDirection: OrderDirection
    where: FlashLoanAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlashLoanAmount!]!
  observationCardinality(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObservationCardinality
  observationCardinalities(
    skip: Int = 0
    first: Int = 100
    orderBy: ObservationCardinality_orderBy
    orderDirection: OrderDirection
    where: ObservationCardinality_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ObservationCardinality!]!
  dailyStat(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyStat
  dailyStats(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyStat_orderBy
    orderDirection: OrderDirection
    where: DailyStat_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyStat!]!
  userActivity(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserActivity
  userActivities(
    skip: Int = 0
    first: Int = 100
    orderBy: UserActivity_orderBy
    orderDirection: OrderDirection
    where: UserActivity_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserActivity!]!
  relayActivity(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RelayActivity
  relayActivities(
    skip: Int = 0
    first: Int = 100
    orderBy: RelayActivity_orderBy
    orderDirection: OrderDirection
    where: RelayActivity_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RelayActivity!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Swap {
  id: ID!
  sender: Bytes!
  recipient: Bytes!
  amount0: BigInt!
  amount1: BigInt!
  sqrtPriceX96: BigInt!
  liquidity: BigInt!
  tick: Int!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  lastSwapPerBlock: LastSwapPerBlock
  priceImpact: PriceImpact!
}

type SwapAmount {
  id: ID!
  swap: Swap!
  amountSize: BigInt!
}

input SwapAmount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  swap: String
  swap_not: String
  swap_gt: String
  swap_lt: String
  swap_gte: String
  swap_lte: String
  swap_in: [String!]
  swap_not_in: [String!]
  swap_contains: String
  swap_contains_nocase: String
  swap_not_contains: String
  swap_not_contains_nocase: String
  swap_starts_with: String
  swap_starts_with_nocase: String
  swap_not_starts_with: String
  swap_not_starts_with_nocase: String
  swap_ends_with: String
  swap_ends_with_nocase: String
  swap_not_ends_with: String
  swap_not_ends_with_nocase: String
  swap_: Swap_filter
  amountSize: BigInt
  amountSize_not: BigInt
  amountSize_gt: BigInt
  amountSize_lt: BigInt
  amountSize_gte: BigInt
  amountSize_lte: BigInt
  amountSize_in: [BigInt!]
  amountSize_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapAmount_filter]
  or: [SwapAmount_filter]
}

enum SwapAmount_orderBy {
  id
  swap
  swap__id
  swap__sender
  swap__recipient
  swap__amount0
  swap__amount1
  swap__sqrtPriceX96
  swap__liquidity
  swap__tick
  swap__blockNumber
  swap__blockTimestamp
  swap__transactionHash
  amountSize
}

input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  recipient: Bytes
  recipient_not: Bytes
  recipient_gt: Bytes
  recipient_lt: Bytes
  recipient_gte: Bytes
  recipient_lte: Bytes
  recipient_in: [Bytes!]
  recipient_not_in: [Bytes!]
  recipient_contains: Bytes
  recipient_not_contains: Bytes
  amount0: BigInt
  amount0_not: BigInt
  amount0_gt: BigInt
  amount0_lt: BigInt
  amount0_gte: BigInt
  amount0_lte: BigInt
  amount0_in: [BigInt!]
  amount0_not_in: [BigInt!]
  amount1: BigInt
  amount1_not: BigInt
  amount1_gt: BigInt
  amount1_lt: BigInt
  amount1_gte: BigInt
  amount1_lte: BigInt
  amount1_in: [BigInt!]
  amount1_not_in: [BigInt!]
  sqrtPriceX96: BigInt
  sqrtPriceX96_not: BigInt
  sqrtPriceX96_gt: BigInt
  sqrtPriceX96_lt: BigInt
  sqrtPriceX96_gte: BigInt
  sqrtPriceX96_lte: BigInt
  sqrtPriceX96_in: [BigInt!]
  sqrtPriceX96_not_in: [BigInt!]
  liquidity: BigInt
  liquidity_not: BigInt
  liquidity_gt: BigInt
  liquidity_lt: BigInt
  liquidity_gte: BigInt
  liquidity_lte: BigInt
  liquidity_in: [BigInt!]
  liquidity_not_in: [BigInt!]
  tick: Int
  tick_not: Int
  tick_gt: Int
  tick_lt: Int
  tick_gte: Int
  tick_lte: Int
  tick_in: [Int!]
  tick_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  lastSwapPerBlock: String
  lastSwapPerBlock_not: String
  lastSwapPerBlock_gt: String
  lastSwapPerBlock_lt: String
  lastSwapPerBlock_gte: String
  lastSwapPerBlock_lte: String
  lastSwapPerBlock_in: [String!]
  lastSwapPerBlock_not_in: [String!]
  lastSwapPerBlock_contains: String
  lastSwapPerBlock_contains_nocase: String
  lastSwapPerBlock_not_contains: String
  lastSwapPerBlock_not_contains_nocase: String
  lastSwapPerBlock_starts_with: String
  lastSwapPerBlock_starts_with_nocase: String
  lastSwapPerBlock_not_starts_with: String
  lastSwapPerBlock_not_starts_with_nocase: String
  lastSwapPerBlock_ends_with: String
  lastSwapPerBlock_ends_with_nocase: String
  lastSwapPerBlock_not_ends_with: String
  lastSwapPerBlock_not_ends_with_nocase: String
  lastSwapPerBlock_: LastSwapPerBlock_filter
  priceImpact: String
  priceImpact_not: String
  priceImpact_gt: String
  priceImpact_lt: String
  priceImpact_gte: String
  priceImpact_lte: String
  priceImpact_in: [String!]
  priceImpact_not_in: [String!]
  priceImpact_contains: String
  priceImpact_contains_nocase: String
  priceImpact_not_contains: String
  priceImpact_not_contains_nocase: String
  priceImpact_starts_with: String
  priceImpact_starts_with_nocase: String
  priceImpact_not_starts_with: String
  priceImpact_not_starts_with_nocase: String
  priceImpact_ends_with: String
  priceImpact_ends_with_nocase: String
  priceImpact_not_ends_with: String
  priceImpact_not_ends_with_nocase: String
  priceImpact_: PriceImpact_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Swap_filter]
  or: [Swap_filter]
}

enum Swap_orderBy {
  id
  sender
  recipient
  amount0
  amount1
  sqrtPriceX96
  liquidity
  tick
  blockNumber
  blockTimestamp
  transactionHash
  lastSwapPerBlock
  lastSwapPerBlock__id
  lastSwapPerBlock__lastSwapId
  priceImpact
  priceImpact__id
  priceImpact__priceBefore
  priceImpact__priceAfter
  priceImpact__impact
}

type TradeSize {
  id: ID!
  swap: Swap!
  sizeToken0: BigInt!
  sizeToken1: BigInt!
}

input TradeSize_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  swap: String
  swap_not: String
  swap_gt: String
  swap_lt: String
  swap_gte: String
  swap_lte: String
  swap_in: [String!]
  swap_not_in: [String!]
  swap_contains: String
  swap_contains_nocase: String
  swap_not_contains: String
  swap_not_contains_nocase: String
  swap_starts_with: String
  swap_starts_with_nocase: String
  swap_not_starts_with: String
  swap_not_starts_with_nocase: String
  swap_ends_with: String
  swap_ends_with_nocase: String
  swap_not_ends_with: String
  swap_not_ends_with_nocase: String
  swap_: Swap_filter
  sizeToken0: BigInt
  sizeToken0_not: BigInt
  sizeToken0_gt: BigInt
  sizeToken0_lt: BigInt
  sizeToken0_gte: BigInt
  sizeToken0_lte: BigInt
  sizeToken0_in: [BigInt!]
  sizeToken0_not_in: [BigInt!]
  sizeToken1: BigInt
  sizeToken1_not: BigInt
  sizeToken1_gt: BigInt
  sizeToken1_lt: BigInt
  sizeToken1_gte: BigInt
  sizeToken1_lte: BigInt
  sizeToken1_in: [BigInt!]
  sizeToken1_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TradeSize_filter]
  or: [TradeSize_filter]
}

enum TradeSize_orderBy {
  id
  swap
  swap__id
  swap__sender
  swap__recipient
  swap__amount0
  swap__amount1
  swap__sqrtPriceX96
  swap__liquidity
  swap__tick
  swap__blockNumber
  swap__blockTimestamp
  swap__transactionHash
  sizeToken0
  sizeToken1
}

type UserActivity {
  id: ID!
  numberOfSwaps: BigInt!
  totalVolume: BigDecimal!
}

input UserActivity_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numberOfSwaps: BigInt
  numberOfSwaps_not: BigInt
  numberOfSwaps_gt: BigInt
  numberOfSwaps_lt: BigInt
  numberOfSwaps_gte: BigInt
  numberOfSwaps_lte: BigInt
  numberOfSwaps_in: [BigInt!]
  numberOfSwaps_not_in: [BigInt!]
  totalVolume: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_lt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UserActivity_filter]
  or: [UserActivity_filter]
}

enum UserActivity_orderBy {
  id
  numberOfSwaps
  totalVolume
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}